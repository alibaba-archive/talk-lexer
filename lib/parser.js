// Generated by CoffeeScript 1.8.0
(function() {
  var invalidNodeType, parseDOM, strParsers, whitelist,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  whitelist = require('./whitelist');

  invalidNodeType = [8];

  strParsers = {
    mention: function(text, opts) {
      var sectionBuffer, structure;
      structure = [];
      sectionBuffer = '';
      text.split('@').forEach(function(section, i) {
        var data, match, mention, opt;
        if (i === 0) {
          return sectionBuffer += section || '';
        }
        for (i in opts) {
          opt = opts[i];
          match = opt.match, data = opt.data;
          if (section.indexOf(match) === 0) {
            mention = {
              type: 'mention',
              text: "@" + match
            };
            if (data != null) {
              mention.data = data;
            }
            structure.push(sectionBuffer, mention);
            sectionBuffer = section.slice(match.length);
            return true;
          }
        }
        return sectionBuffer += "@" + section;
      });
      structure.push(sectionBuffer);
      return structure;
    }
  };

  parseDOM = function(nodes, options) {
    var structure, _i, _ref, _results;
    structure = [];
    (function() {
      _results = [];
      for (var _i = 0, _ref = nodes.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(i) {
      var node, nodeType, obj, opts, parser, tagName, text, _i, _ref, _ref1, _results;
      node = nodes[i];
      tagName = node.tagName, nodeType = node.nodeType;
      if (tagName != null) {
        tagName = tagName.toLowerCase();
      }
      if (__indexOf.call(invalidNodeType, nodeType) >= 0) {
        return;
      }
      if (!((tagName != null) && whitelist[tagName])) {
        text = node.textContent;
        if (!text.length) {
          return;
        }
        for (parser in options) {
          opts = options[parser];
          if (typeof strParsers[parser] !== 'function') {
            continue;
          }
          text = strParsers[parser].call(strParsers, text, opts);
        }
        if (toString.call(text) === '[object Array]') {
          structure = structure.concat(text);
        } else {
          structure.push(text);
        }
        return false;
      }
      obj = {
        type: tagName,
        text: node.textContent
      };
      obj.data = {};
      (function() {
        _results = [];
        for (var _i = 0, _ref = (_ref1 = node.attributes) != null ? _ref1.length : void 0; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).forEach(function(i) {
        var attr, key, prefix, _ref;
        attr = node.attributes[i];
        _ref = attr.name.split('-'), prefix = _ref[0], key = _ref[1];
        if (prefix === 'data' && (key != null)) {
          return obj.data[key] = attr.value;
        }
      });
      return structure.push(obj);
    });
    return structure;
  };

  module.exports = {
    parseDOM: parseDOM
  };

}).call(this);
