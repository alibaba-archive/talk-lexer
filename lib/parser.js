// Generated by CoffeeScript 1.8.0
(function() {
  var invalidNodeType, parseDOM, parserMap, toString, whitelist,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  whitelist = require('./whitelist');

  toString = Object.prototype.toString;

  invalidNodeType = [8];

  parserMap = {
    "default": function(node) {
      var nodeType, obj, tagName, textContent, _i, _ref, _ref1, _results;
      tagName = node.tagName, nodeType = node.nodeType, textContent = node.textContent;
      obj = {
        type: tagName.toLowerCase(),
        text: node.textContent
      };
      obj.data = {};
      (function() {
        _results = [];
        for (var _i = 0, _ref = (_ref1 = node.attributes) != null ? _ref1.length : void 0; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).forEach(function(i) {
        var attr, key, prefix, _ref;
        attr = node.attributes[i];
        _ref = attr.name.split('-'), prefix = _ref[0], key = _ref[1];
        if (prefix === 'data' && (key != null)) {
          return obj.data[key] = attr.value;
        }
      });
      return obj;
    },
    mention: function(node, opts) {
      var nodeType, sectionBuffer, structure, tagName, textContent;
      tagName = node.tagName, nodeType = node.nodeType, textContent = node.textContent;
      if (tagName === 'MENTION') {
        return parserMap["default"](node);
      }
      if (tagName) {
        return false;
      }
      structure = [];
      sectionBuffer = '';
      textContent.split('@').forEach(function(section, i) {
        var data, match, mention, opt;
        if (i === 0) {
          return sectionBuffer += section || '';
        }
        for (i in opts) {
          opt = opts[i];
          match = opt.match, data = opt.data;
          if (section.indexOf(match) === 0) {
            mention = {
              type: 'mention',
              text: "@" + match
            };
            if (data != null) {
              mention.data = data;
            }
            structure.push(sectionBuffer, mention);
            sectionBuffer = section.slice(match.length);
            return true;
          }
        }
        return sectionBuffer += "@" + section;
      });
      structure.push(sectionBuffer);
      return structure;
    },
    link: function(node, opts) {
      var classList, href, nodeType, tagName, textContent;
      tagName = node.tagName, nodeType = node.nodeType, classList = node.classList, href = node.href, textContent = node.textContent;
      classList || (classList = []);
      if (!(__indexOf.call(classList, 'lexer-link') >= 0 && tagName === 'A')) {
        return false;
      }
      return {
        type: 'link',
        href: href,
        text: textContent
      };
    },
    highlight: function(node, opts) {
      var classList, href, nodeType, tagName, textContent;
      tagName = node.tagName, nodeType = node.nodeType, classList = node.classList, href = node.href, textContent = node.textContent;
      classList || (classList = []);
      if (!(__indexOf.call(classList, 'lexer-highlight') >= 0 && tagName === 'EM')) {
        return false;
      }
      return {
        type: 'highlight',
        text: textContent
      };
    }
  };

  parseDOM = function(nodes, options) {
    var structure, _i, _ref, _results;
    if (options == null) {
      options = {};
    }
    structure = [];
    (function() {
      _results = [];
      for (var _i = 0, _ref = nodes.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).forEach(function(i) {
      var judge, node, nodeType, tagName, text;
      node = nodes[i];
      nodeType = node.nodeType, tagName = node.tagName;
      if (__indexOf.call(invalidNodeType, nodeType) >= 0) {
        return;
      }
      if (tagName === 'BR') {
        return structure.push('\n');
      }
      judge = Object.keys(whitelist).some(function(parserKey) {
        var obj;
        if (typeof parserMap[parserKey] !== 'function') {
          return false;
        }
        obj = parserMap[parserKey](node, options[parserKey]);
        if (toString.call(obj) === '[object Array]') {
          structure = structure.concat(obj);
        } else if (obj) {
          structure.push(obj);
        }
        return obj;
      });
      if (!judge) {
        text = node.textContent;
        if (!text.length) {
          return;
        }
        if (tagName === 'DIV') {
          text += '\n';
        }
        return structure.push(text);
      }
    });
    return structure;
  };

  module.exports = {
    parseDOM: parseDOM
  };

}).call(this);
